-module(routes_v1_server).

%% this file was generated by grpc

-export([
    decoder/0,
    get_routes/3,
    stream_route_updates/3
]).

-type 'Empty'() :: #{}.

-type routing_v1() :: #{
    oui => integer(),
    owner => binary(),
    router_addresses => [binary()],
    filters => [binary()],
    subnets => [binary()]
}.

-type routing_v1_response() :: #{
    routes => [routing_v1()],
    signature => binary(),
    height => integer()
}.

-type routing_v1_update() :: #{
    route => routing_v1(),
    signature => binary(),
    height => integer(),
    action => binary()
}.

-export_type([
    routing_v1/0,
    routing_v1_response/0,
    routing_v1_update/0
]).

-spec decoder() -> module().
%% The module (generated by gpb) used to encode and decode protobuf
%% messages.
decoder() -> routes_v1.

%% RPCs for service routes_v1

-spec get_routes(Message :: 'Empty'(), Stream :: grpc:stream(), State :: any()) ->
    {routing_v1_response(), grpc:stream()} | grpc:error_response().
%% This is a unary RPC
get_routes(_Message, Stream, _State) ->
    lager:debug("pid: ~p stream: ~p, state: ~p", [self(), Stream, _State]),
    Chain = sibyl_mgr:blockchain(),
    Ledger = blockchain:ledger(Chain),
    {ok, CurHeight} = blockchain_ledger_v1:current_height(Ledger),
    {ok, Routes} = blockchain_ledger_v1:get_routes(Ledger),
    RoutesPB = serialize_response(Routes, CurHeight, sibyl_mgr:sigfun()),
    {RoutesPB, Stream}.

-spec stream_route_updates(Message :: 'Empty'(), Stream :: grpc:stream(), State :: any()) ->
    {[routing_v1_update()], grpc:stream()} | grpc:error_response().
%% This is a server-to-client streaming RPC
stream_route_updates(_Message, Stream, _State) ->
    %% as this grpc lib does not pass info msgs up the stack this far
    %% start a server which will subscribe to updates and pass it the stream handle
    %% the server will then send updates directly to the client
    %% we only need to return the continue directive here to let the client
    %% know to expect msgs
    {ok, _WorkerPid} = route_updates_sup:start_route_stream_worker(Stream),
    lager:debug("started route update worker pid ~p", [_WorkerPid]),
    {continue, Stream, _State}.

%% ------------------------------------------------------------------
%% Internal functions
%% ------------------------------------------------------------------
-spec serialize_response([blockchain_ledger_routing_v1:routing()], non_neg_integer(), function()) ->
    routing_v1_response().
serialize_response(Routes, Height, SigFun) ->
    RoutingInfo = [to_routing_pb(R) || R <- Routes],
    Resp = #{
        routes => RoutingInfo,
        height => Height
    },
    EncodedRoutingInfoBin = routes_v1:encode_msg(Resp, routing_v1_response),
    Resp#{signature => SigFun(EncodedRoutingInfoBin)}.

-spec to_routing_pb(blockchain_ledger_routing_v1:routing()) -> routing_v1().
to_routing_pb(Route) ->
    #{
        oui => blockchain_ledger_routing_v1:oui(Route),
        owner => blockchain_ledger_routing_v1:owner(Route),
        router_addresses => blockchain_ledger_routing_v1:addresses(Route),
        filters => blockchain_ledger_routing_v1:filters(Route),
        subnets => blockchain_ledger_routing_v1:subnets(Route)
    }.
